
node-modules
hessian.js.2015-09-06T13:26:36Z"2015-09-06T17:25:01Z*writeLong method to support string val

之前有个bug，没有兼容long类型传string的情况，下面case就报错了
hessian.encode({
  $class: 'long',
  $: '2'
}, 2.0);

// HSFEncodeRequestError: src.copy is not a function2H
(964d4b1795120edf30d8e2ab92f17f2ee35a4ef62015-09-06T17:25:01Z985607:
2015-09-06T17:24:59Z+1:
2015-09-06T17:30:21Z2.1.192015-12-11T05:50:58Z"2016-03-10T11:32:53Z*如题，关联 issue #562H
(ed102d096883428073795c61777b57efabef85172016-03-10T11:32:53Z156269:
2015-12-11T05:51:01ZCurrent coverage is 92.02%

Merging #57 into master will decrease coverage by -3.77% as of e442d5a

@@            master     #57   diff @@
======================================
  Files            7       7       
  Stmts         1022    1028     +6
  Branches         0     171   +171
  Methods          0       0       
======================================
- Hit            979     946    -33
- Partial          0      39    +39
  Missed          43      43       

Review entire Coverage Diff as of e442d5a
Powered by Codecov. Updated on successful CI builds.:~
2015-12-11T09:32:42Zf这不科学……因为实现代码变少了导致覆盖率降低了……，哎，晚点再修一下:/
2015-12-11T10:04:15Zcommit author 改一下:
2015-12-15T04:06:03Zcommit 已修改，关于覆盖率的问题，有点晕啊，好几个文件覆盖率都有下降，单看改动的 utils.js 的 cov diff，改动的地方覆盖信息明显有问题啊，两个 return 都没走到，而且修改的测试用例是明显会走到这几行的，本地测试也覆盖到了，啥情况？:
2015-12-15T05:35:08Zdone！:M
2015-12-15T11:43:30Z5long有问题，如果使用中用的是 long@2呢？:F
2015-12-23T10:43:25Z.@fengmk2 long 是什么问题？没 get 到点:
2016-03-11T07:05:21Z2.1.6/2015-09-08T18:03:45Z"2015-09-10T15:56:52Z2H
(bd14cde77ed746286fbef304076d56c8b37547ff2015-09-10T15:56:52Z156269:*
2015-09-08T18:06:41Z看上去没问题:E
2015-09-10T10:25:22Z-如果没有别的什么问题就先合了？:
2015-09-10T15:56:44Z+1:H
2015-09-10T17:11:44Z0这个是避免不必要的循环属性是吧？:
2015-09-10T17:13:47Z@gxcsoccer 是的，在调用 JSON.stringify 的时候会导致无限循环引用然后异常，但是这个特性对我们来说没什么用处。:$
2015-09-10T17:17:19Z明白了
+1:
2015-09-10T17:36:38Z2.1.202015-09-30T17:50:29Z"2015-09-30T18:54:26Z2H
(74a841514695118544fb06eceb75a8a17469eeb62015-09-30T18:54:26Z156269:2
2015-09-30T18:38:46Z我加个 undefined 测试:
2015-09-30T18:53:36ZCurrent coverage is 95.79%

Branch #48 has no coverage reports uploaded yet.
No diff could be generated. No reports for master found.
Review entire Coverage Diff as of c7bce6b
Powered by Codecov. Updated on successful CI builds.:
2015-09-30T18:54:23Z+1:
2015-09-30T18:56:07Z2.1.312015-10-11T04:35:53Z"2015-10-11T06:58:37Z2H
(dcdf3132e536702b6d7fa5dd3afbfd63c77f439a2015-10-11T06:58:37Z985607:
2015-10-11T05:18:52ZCurrent coverage is 95.79%

Merging #49 into master will not affect coverage as of da82021

@@            master     #49   diff @@
======================================
  Files            7       7       
  Stmts         1022    1022       
  Branches         0       0       
  Methods          0       0       
======================================
  Hit            979     979       
  Partial          0       0       
  Missed          43      43       

Review entire Coverage Diff as of da82021
Powered by Codecov. Updated on successful CI builds.:
2015-10-11T06:58:34Z+1:2
2015-10-12T07:50:31Z呃。。。 cc @gxcsoccer	&2015-03-11T07:39:35Z"2015-03-11T07:59:30Z2H
(f22c27617edcba99bdd6a9f1f7c3daa99797d0912015-03-11T07:59:30Z985607:-
2015-03-11T07:59:57Z你有发布权限么:9
2015-03-11T08:00:24Z!貌似没，你帮我加下吧。:B
2015-03-11T08:06:16Z*加下权限，我推送一下就好了。:
2015-03-11T08:15:34Z可以用这样的方式得到序列化字节（一些特殊类型除外）
ByteArrayOutputStream output = new ByteArrayOutputStream();
HessianOutput ho = new HessianOutput(output);
Map args2 = new HashMap();
args2.put(null, "null");
byte[] bts =  output.toByteArray();
System.err.println(bts);:7
2015-03-11T09:08:41Z哈哈，bug 还是挺少的。:8
2015-03-11T09:10:46Z @coolme200 �加了发布权限G2016-08-25T11:40:10Z"2016-08-25T11:52:33Z2I
(37d19e74151a07d7709f2e6e867e39d71e2a0bd92016-08-25T11:52:33Z1207064:
2016-08-25T11:40:13Z@gxcsoccer, thanks for your PR! By analyzing the annotation information on this pull request, we identified @fengmk2 and @dead-horse to be potential reviewers:
2016-08-25T11:49:53Z+1:>
2016-08-25T11:52:19Z&本地跑过了，不等 travis ci 了:
2016-08-25T11:54:25Z2.2.1=2016-04-01T11:11:35Z"2016-04-01T15:50:40Z2H
(02b0ab274f794901b4af4da80403c22b2ca4d6e22016-04-01T15:50:40Z156269:
2016-04-01T11:11:37ZBy analyzing the blame information on this pull request, we identified @fengmk2, @gxcsoccer and @dead-horse to be potential reviewers:.
2016-04-01T11:12:12Z@gxcsoccer @dead-horse:I
2016-04-01T12:03:38Z1+1 我在机场，麻烦 @fengmk2 后面操作下:
2016-04-01T12:37:36ZCurrent coverage is 95.92%

Merging #61 into master will increase coverage by +0.01% as of d0acbbc

@@            master     #61   diff @@
======================================
  Files            7       7       
  Stmts         1028    1031     +3
  Branches       171     171       
  Methods          0       0       
======================================
+ Hit            986     989     +3
  Partial          3       3       
  Missed          39      39       

Review entire Coverage Diff as of d0acbbc
Powered by Codecov. Updated on successful CI builds.:
2016-04-01T15:50:31Z+1:
2016-04-01T15:53:31Z2.1.7:1
2017-10-18T05:26:44Z需要同时修复到 1.x$)2015-04-08T15:43:01Z"2015-04-09T08:32:20Z*Yshould write null for property like: { a: { "$class": "yyy.yyy", "$": null } }

issue #402H
(7c06f92bb85f47a3a9ed5c598b2157cd76bc76fa2015-04-09T08:32:20Z156269:
2015-04-08T16:24:01Zw是否有可能对现有的代码产生影响？
现在如果传 {$class: 'java.lang.Long', $: null} 是会报错么？:
2015-04-08T18:07:32Z{$class: 'java.lang.Long', $: null}  不会受影响，主要是针对一个对象的属性也是对象的情况，比如
public class X {
    private java.lang.Long id;
    private Y group;
}
如果group要传null的化，以前的写法是：
var java = require('js-to-java');

java('X', {
   id: java('java.lang.Long', 123),
   group: null
})
现在可以这样写：
var java = require('js-to-java');

java('X', {
   id: java('java.lang.Long', 123),
   group: java('Y', null)
}):4
2015-04-08T18:08:42ZLGTM, cc @coolme200 @fengmk2:
2015-04-08T18:13:43Z我记得当初 @coolme200 是因为 java('java.lang.Long', null) 不允许设置为 null，才改成现在这样子的，现在又改回去？:V
2015-04-08T18:17:01Z>{$class: 'java.lang.Long', $: null} 也会变成 writeNull 吧:
2015-04-08T18:17:43Zt如果是作为参数传递时必须是  {$class: 'java.lang.Long', $: null}, 如果是对象属性时直接传 null:M
2015-04-08T18:18:37Z5@coolme200 不明白你说的两个有什么差别？:
2015-04-08T18:21:01Zhessian 在反序列化的时，参数的类型是未知的需要通过关键信息传递 {$class: 'java.lang.Long', $: null}
如果对象的某个属性，因为属性的类型是已知的，反序列化时会先根据这个类型创建一个实例出来，然后再把对应的值赋给他。如果传了  {$class: 'java.lang.Long', $: null}, 他就认为这个是有值的，就先创建实例了，就非 null 了。:s
2015-04-08T18:22:38Z[那应该实际调用中应该传递 {$class: 'java.lang.Long', $: null} 还是 null 呢？:h
2015-04-08T18:24:19ZP@gxcsoccer 按你的说法，应该是去改 js-to-java，而不是改hessian.js:
2015-04-08T18:25:33Zm有选择的传递，所以我是通过 proxy-args-convertor 结合 js-to-java 来控制具体传什么值。:n
2015-04-08T18:26:34ZV这个地方的修改应该只改了 $class 为自定义对象的时候的表现把？:B
2015-04-08T18:26:44Z*在 js-to-java 这里修改也不太合理:
2015-04-08T18:27:42Zn@dead-horse 不是的，hessian writeObject 压根地不知道你是自定义对象，还是原始类型的。:
2015-04-08T18:29:42Zr按这个 pr 改了，{$class: 'java.lang.Long', $: null} 就变成 writeNull 了，java.lang.Long 信息就丢了:
2015-04-08T18:31:05Zj@gxcsoccer 你加一个 hessian.encode({$class: 'java.lang.Long', $: null}) 的测试用例看看就知道:
2015-04-08T18:34:26Z看代码如果是 hessian.write({$class: 'java.lang.Long', $: null}) 不会走到 writeObject 的，会走到 writeLong 的吧:y
2015-04-08T18:34:56Za都快忘记了，hessian.encode({$class: 'java.lang.Long', $: null}) 这个测试还是要加的:
2015-04-09T04:15:42Z如果是作为参数传递时必须是 {$class: 'java.lang.Long', $: null}, 如果是对象属性时直接传 null

就是这个很奇怪
{$class: 'java.lang.Long', $: null}  这个以前也是writeNull吧？
if (method !== 'writeObject' && method !== 'writeArray') {
    if (is.nullOrUndefined(val.$)) {
      return this.writeNull();
    }
    return this[method](val.$);
  }:<
2015-04-09T04:16:25Z$ping @coolme200 @fengmk2 @dead-horse:
2015-04-09T04:23:05Zhessian.js 其实不用关心传入的是什么内容，下面是我说的2种情况的参数传入方式。
这里的 name 属性最好不要去制定 $class 类型，否则很容易导致 java 端 反序列化失败。
var rv = hessian.encode([{$class: 'java.lang.Lang', $: null}]);
console.log(rv);

var rv = hessian.encode([{$class: 'x', $: {name: null}}]);
console.log(rv);:
2015-04-09T06:47:44Z一个java方法如 foo(int)，foo(string)，如果丢掉了参数类型，是找不到这个类方法的。
Sent from my iPhone

On Apr 9, 2015, at 10:15 AM, GaoXiaochen notifications@github.com wrote:
如果是作为参数传递时必须是 {$class: 'java.lang.Long', $: null}, 如果是对象属性时直接传 null
就是这个很奇怪
{$class: 'java.lang.Long', $: null} 这个以前也是writeNull吧？
if (method !== 'writeObject' && method !== 'writeArray') {
if (is.nullOrUndefined(val.$)) {
return this.writeNull();
}
return thismethod;
}
—
Reply to this email directly or view it on GitHub.:
2015-04-09T08:32:11Z+1:=
2015-04-09T08:52:11Z%publish bugfix patch hessian.js@1.0.4